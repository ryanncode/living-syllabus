const fs = require('fs');
const juice = require('juice');
const pandoc = require('node-pandoc');
const postcss = require('postcss');
const cssVariables = require('postcss-css-variables');
const path = require('path');

// Usage: node generate.js <input_file> <theme_name>
// Example (Markdown): node generate.js week1.md academic
// Example (Word):     node generate.js syllabus.docx midnight

const args = process.argv.slice(2);

if (args.length < 2) {
    console.error("‚ùå Error: Please provide both an input file and a theme.");
    console.error("   Usage: node generate.js <file.md|file.docx> <theme>");
    process.exit(1);
}

const inputFile = args[0];
const themeName = args[1];

// Generate output name: inputfilename_themename.html
const baseName = path.basename(inputFile, path.extname(inputFile));
const outputFile = `${baseName}_${themeName}.html`;

// Theme Resolution Logic
let cssFile = `${themeName}.css`;
// Check root first, then themes folder
if (!fs.existsSync(cssFile)) {
    if (fs.existsSync(`./themes/${cssFile}`)) {
         cssFile = `./themes/${cssFile}`;
    } else {
        console.error(`‚ùå Error: Theme file '${themeName}.css' not found in root or /themes.`);
        process.exit(1);
    }
}

async function buildComponent() {
    console.log(`\nüèóÔ∏è  Compiling [${inputFile}] with [${themeName.toUpperCase()}] Theme`);

    if (!fs.existsSync(inputFile)) {
        console.error(`‚ùå Error: Source file '${inputFile}' not found.`);
        return;
    }

    // 1. DETERMINE FILE TYPE & CONVERTER ARGS
    const fileExt = path.extname(inputFile).toLowerCase();
    let pandocArgs = '';

    if (fileExt === '.md' || fileExt === '.markdown') {
        console.log(`   ...Detected Markdown file. Using Markdown converter...`);
        // --section-divs adds <section> or <div> wrappers around headers, good for styling
        pandocArgs = '-f markdown -t html5 --wrap=none --section-divs';
    } else if (fileExt === '.docx') {
        console.log(`   ...Detected Word document. Using Docx converter...`);
        pandocArgs = '-f docx -t html5 --wrap=none --section-divs';
    } else {
        console.error(`‚ùå Error: Unsupported file type '${fileExt}'. Please use .md or .docx`);
        return;
    }

    // 2. CSS PRE-PROCESSING (The "Flattening" Step)
    const rawCss = fs.readFileSync(cssFile, 'utf8');
    
    // Sanitization: Replace :host with :root and neutralize complex data URIs
    let sanitizedCss = rawCss.replace(/:host/g, ':root');
    sanitizedCss = sanitizedCss.replace(/url\("data:[^"]+"\)/g, 'none');

    console.log(`   ...Flattening CSS variables...`);
    let flatCss = '';
    
    try {
        const result = await postcss([
            cssVariables({ preserve: false }) 
        ]).process(sanitizedCss, { from: cssFile, to: undefined });
        flatCss = result.css;
    } catch (err) {
        console.error('‚ùå CSS Compilation Error:', err);
        return;
    }

    // 3. PANDOC CONVERSION (The "Compiler" Step)
    console.log(`   ...Converting Content to HTML...`);
    
    pandoc(inputFile, pandocArgs, (err, htmlContent) => {
        if (err) {
            console.error('‚ùå Pandoc Error:', err);
            return;
        }

        // 4. INJECTION (The "Container" Step)
        // Wraps content in a generic canvas-component div for scoping
        const wrappedHtml = `
            <div class="canvas-component" style="max-width: 800px; margin: 0 auto; font-family: sans-serif;">
                ${htmlContent}
            </div>
            `;

        // 5. INLINING (The "Chemical Bonding" Step)
        // Inlines the flattened CSS directly into the HTML style attributes
        const finalHtml = juice.inlineContent(wrappedHtml, flatCss, {
            applyStyleTags: true,
            removeStyleTags: true,
            preserveMediaQueries: false, 
            widthElements: ['table', 'td', 'th'] 
        });

        // 6. FORENSIC STAMPING
        const stamp = `<!-- Generated by Canvas Component Engine on ${new Date().toISOString()} -->\n`;

        fs.writeFileSync(outputFile, stamp + finalHtml);
        console.log(`‚úÖ Success! Component generated: ${outputFile}`);
        console.log(`üëâ Next: Open this file, Select All, and Paste into Canvas HTML Editor.`);
    });
}

buildComponent();